# ArgoCD Installation Values
# Apply manually during bootstrap:
#   helm repo add argo https://argoproj.github.io/argo-helm
#   helm install argocd argo/argo-cd -n argocd --create-namespace -f values.yaml

# Global settings
global:
  domain: argocd.rex5.ca

  # Tolerate spot nodes (required for AKS spot node pools)
  tolerations:
    - key: "kubernetes.azure.com/scalesetpriority"
      operator: "Equal"
      value: "spot"
      effect: "NoSchedule"

  # Prefer spot nodes for cost optimization
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 1
          preference:
            matchExpressions:
              - key: "kubernetes.azure.com/scalesetpriority"
                operator: In
                values:
                  - "spot"

# Server configuration
server:
  replicas: 2

  # Extra args for insecure mode (TLS terminated at ingress)
  extraArgs:
    - --insecure

  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

# Repo server
repoServer:
  replicas: 2
  
  # Pod labels for Workload Identity (required for token injection)
  podLabels:
    azure.workload.identity/use: "true"
  
  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi
  
  # Workload Identity for CZ cluster access
  serviceAccount:
    annotations:
      azure.workload.identity/client-id: "63de6227-6397-4376-bb12-741e739440f0"
      azure.workload.identity/tenant-id: "14021cba-cdc0-4c87-a145-b66f94b7017f"
    labels:
      azure.workload.identity/use: "true"
  
  # Add kubelogin for Azure AD Workload Identity authentication
  volumes:
    - name: kubelogin
      emptyDir: {}
  volumeMounts:
    - name: kubelogin
      mountPath: /usr/local/bin/kubelogin
      subPath: kubelogin
  initContainers:
    - name: download-kubelogin
      image: mcr.microsoft.com/azure-cli:latest
      command:
        - sh
        - -c
        - |
          az aks install-cli --only-show-errors --kubelogin-install-location /kubelogin/kubelogin
      volumeMounts:
        - name: kubelogin
          mountPath: /kubelogin

# Application controller
controller:
  # HA: 2 replicas for high availability
  replicas: 2

  # Required for HA mode - controller uses sharding
  env:
    - name: ARGOCD_CONTROLLER_REPLICAS
      value: "2"

  # Pod labels for Workload Identity (required for token injection)
  podLabels:
    azure.workload.identity/use: "true"

  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi
  
  # -------------------------------------------------------------------------
  # Workload Identity for CZ Cluster Management
  # -------------------------------------------------------------------------
  # This annotation enables the MZ ArgoCD controller to authenticate to the
  # CZ cluster using Azure AD Workload Identity.
  #
  # The federated credential on rex5-cc-cz-prod-argocd-identity trusts:
  #   Subject: system:serviceaccount:rex5-cc-mz-k8s-argocd:argocd-application-controller
  #
  # See: argocd/deployments/cz/cz-cluster-secret.yaml for cluster registration
  # -------------------------------------------------------------------------
  serviceAccount:
    annotations:
      azure.workload.identity/client-id: "63de6227-6397-4376-bb12-741e739440f0"
      azure.workload.identity/tenant-id: "14021cba-cdc0-4c87-a145-b66f94b7017f"
    labels:
      azure.workload.identity/use: "true"
  
  # Add kubelogin for Azure AD Workload Identity authentication
  volumes:
    - name: kubelogin
      emptyDir: {}
  volumeMounts:
    - name: kubelogin
      mountPath: /usr/local/bin/kubelogin
      subPath: kubelogin
  initContainers:
    - name: download-kubelogin
      image: mcr.microsoft.com/azure-cli:latest
      command:
        - sh
        - -c
        - |
          az aks install-cli --only-show-errors --kubelogin-install-location /kubelogin/kubelogin
      volumeMounts:
        - name: kubelogin
          mountPath: /kubelogin

# Redis
redis:
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 200m
      memory: 256Mi

# Disable built-in ingress (we use Gateway API)
server:
  ingress:
    enabled: false

# Config settings
configs:
  params:
    # Server settings
    server.insecure: true  # TLS at Gateway level

  cm:
    # URL for ArgoCD
    url: https://argocd.rex5.ca

    # Enable status badge
    statusbadge.enabled: true

    # Resource customizations (ignore webhook CA bundles)
    resource.customizations.ignoreDifferences.admissionregistration.k8s.io_ValidatingWebhookConfiguration: |
      jqPathExpressions:
        - .webhooks[].clientConfig.caBundle
    resource.customizations.ignoreDifferences.admissionregistration.k8s.io_MutatingWebhookConfiguration: |
      jqPathExpressions:
        - .webhooks[].clientConfig.caBundle

    # Custom health checks for CRDs
    resource.customizations.health.external-secrets.io_ExternalSecret: |
      hs = {}
      if obj.status ~= nil and obj.status.conditions ~= nil then
        for i, c in ipairs(obj.status.conditions) do
          if c.type == "Ready" then
            if c.status == "True" then
              hs.status = "Healthy"
              hs.message = c.message or "Secret synced successfully"
              return hs
            else
              hs.status = "Degraded"
              hs.message = c.message or "Secret sync failed"
              return hs
            end
          end
        end
      end
      hs.status = "Progressing"
      hs.message = "Waiting for secret sync"
      return hs

    resource.customizations.health.external-secrets.io_ClusterSecretStore: |
      hs = {}
      if obj.status ~= nil and obj.status.conditions ~= nil then
        for i, c in ipairs(obj.status.conditions) do
          if c.type == "Ready" then
            if c.status == "True" then
              hs.status = "Healthy"
              hs.message = c.message or "SecretStore ready"
              return hs
            else
              hs.status = "Degraded"
              hs.message = c.message or "SecretStore not ready"
              return hs
            end
          end
        end
      end
      hs.status = "Progressing"
      hs.message = "Waiting for SecretStore to be ready"
      return hs

  # RBAC settings
  rbac:
    policy.default: role:readonly
    policy.csv: |
      g, argocd-admins, role:admin

# Notifications controller
notifications:
  enabled: true
  argocdUrl: https://argocd.rex5.ca

  # Notification templates
  templates:
    template.app-sync-failed: |
      message: |
        Application {{.app.metadata.name}} sync failed.
        Project: {{.app.spec.project}}
        Sync Status: {{.app.status.sync.status}}
        Health: {{.app.status.health.status}}
        {{if .app.status.operationState}}
        Message: {{.app.status.operationState.message}}
        {{end}}
        Details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}

    template.app-health-degraded: |
      message: |
        Application {{.app.metadata.name}} health is degraded.
        Project: {{.app.spec.project}}
        Health: {{.app.status.health.status}}
        Details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}

    template.app-sync-succeeded: |
      message: |
        Application {{.app.metadata.name}} synced successfully.
        Project: {{.app.spec.project}}
        Revision: {{.app.status.sync.revision}}

  # Triggers define when to send notifications
  triggers:
    trigger.on-sync-failed: |
      - when: app.status.operationState != nil and app.status.operationState.phase in ['Error', 'Failed']
        send: [app-sync-failed]

    trigger.on-health-degraded: |
      - when: app.status.health.status == 'Degraded'
        send: [app-health-degraded]

    trigger.on-sync-succeeded: |
      - when: app.status.operationState != nil and app.status.operationState.phase == 'Succeeded'
        send: [app-sync-succeeded]

  # Default triggers to subscribe all apps to
  subscriptions:
    - recipients:
        - ""  # TODO: Add notification target (e.g., slack:argocd-alerts)
      triggers:
        - on-sync-failed
        - on-health-degraded

  # Notifiers configuration (uncomment and configure as needed)
  # notifiers:
  #   service.slack: |
  #     token: $slack-token
  #   service.webhook.default: |
  #     url: https://your-webhook-url
  #     headers:
  #       - name: Content-Type
  #         value: application/json
